<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Taxonle - Discover the Animal Kingdom</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #52c234 0%, #a8d530 100%);
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        .header {
            background: white;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 12px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
            z-index: 100;
        }

        .header-left, .header-right {
            display: flex;
            gap: 8px;
            align-items: center;
            min-width: 80px;
        }

        .header-right {
            justify-content: flex-end;
        }

        .header-center {
            flex: 1;
            text-align: center;
        }

        .header h1 {
            font-size: 1.5em;
            color: #2d7a1f;
            margin: 0;
        }

        .icon-btn {
            background: none;
            border: none;
            font-size: 1.3em;
            cursor: pointer;
            padding: 6px;
            border-radius: 8px;
            transition: background-color 0.2s;
            color: #2d7a1f;
            width: auto;
            line-height: 1;
        }

        .icon-btn:hover {
            background: #f0f0f0;
        }

        .guess-counter {
            font-weight: bold;
            color: #2d7a1f;
            font-size: 1em;
            white-space: nowrap;
        }

        /* Slide-out Menu */
        .menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 998;
            display: none;
        }

        .menu-overlay.active {
            display: block;
        }

        .menu-panel {
            position: fixed;
            top: 0;
            left: -300px;
            width: 280px;
            height: 100%;
            background: white;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.3);
            z-index: 999;
            transition: left 0.3s ease;
            display: flex;
            flex-direction: column;
            padding: 20px;
        }

        .menu-panel.active {
            left: 0;
        }

        .menu-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 15px;
            border-bottom: 2px solid #52c234;
        }

        .menu-header h2 {
            color: #2d7a1f;
            font-size: 1.3em;
        }

        .menu-items {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .menu-section {
            margin-bottom: 20px;
        }

        .menu-section h3 {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 10px;
            text-transform: uppercase;
        }

        .menu-btn {
            padding: 15px;
            font-size: 1em;
            text-align: left;
            border: none;
            background: #f8f9fa;
            color: #333;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
            font-weight: 500;
            width: 100%;
        }

        .menu-btn:hover {
            background: #e9ecef;
        }

        .menu-btn.primary {
            background: #ffa500;
            color: white;
        }

        .menu-btn.primary:hover {
            background: #e69500;
        }

        .menu-btn.danger {
            background: #dc3545;
            color: white;
        }

        .menu-btn.danger:hover {
            background: #c82333;
        }

        .menu-btn.settings {
            background: #6c757d;
            color: white;
        }

        .menu-btn.settings:hover {
            background: #5a6268;
        }

        .hint-info {
            background: #d1ecf1;
            padding: 12px;
            border-radius: 8px;
            font-size: 0.9em;
            color: #0c5460;
            margin-top: 10px;
        }

        /* Main Tree Area */
        .tree-area {
            flex: 1;
            overflow: auto;
            position: relative;
            background: white;
            margin: 10px;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 20px;
        }

        .tree-container {
            position: relative;
            min-width: min-content;
        }

        .empty-tree {
            text-align: center;
            color: #999;
            padding: 40px 20px;
        }

        .empty-tree-icon {
            font-size: 3em;
            margin-bottom: 10px;
        }

        /* Bottom Input Bar */
        .input-bar {
            background: white;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
            padding: 12px 15px;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-shrink: 0;
            z-index: 100;
        }

        .search-wrapper {
            position: relative;
            flex: 1;
        }

        input[type="text"] {
            width: 100%;
            padding: 12px 15px;
            font-size: 1em;
            border: 2px solid #ddd;
            border-radius: 25px;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #52c234;
        }

        .autocomplete-list {
            position: absolute;
            bottom: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid #52c234;
            border-bottom: none;
            border-radius: 8px 8px 0 0;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
            box-shadow: 0 -4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 2px;
        }

        .autocomplete-list.active {
            display: block;
        }

        .autocomplete-item {
            padding: 10px 15px;
            cursor: pointer;
            transition: background-color 0.2s;
            border-bottom: 1px solid #f0f0f0;
        }

        .autocomplete-item:hover {
            background-color: #f0fff0;
        }

        .autocomplete-item-name {
            font-weight: bold;
            color: #333;
        }

        .autocomplete-item-scientific {
            font-size: 0.85em;
            color: #666;
            font-style: italic;
            margin-top: 2px;
        }

        .submit-btn {
            padding: 12px 24px;
            font-size: 1em;
            background: #52c234;
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: background-color 0.3s;
            font-weight: bold;
            white-space: nowrap;
        }

        .submit-btn:hover {
            background: #3da328;
        }

        .submit-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        /* Tree Styles */
        .tree-svg {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 1;
            overflow: visible;
        }

        .tree-content {
            position: relative;
            z-index: 2;
            display: inline-block;
            min-width: min-content;
        }

        .tree-root {
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }

        .tree-branch-group {
            display: inline-flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            margin: 0 15px;
        }

        .tree-children {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            gap: 12px;
            margin-top: 40px;
            flex-wrap: nowrap;
        }

        .tree-node-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }

        .tree-node {
            display: inline-block;
            padding: 8px 12px;
            border-radius: 8px;
            font-weight: 500;
            min-width: 80px;
            text-align: center;
            position: relative;
            animation: fadeIn 0.5s ease-out;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            font-size: 0.9em;
        }

        .tree-node:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: scale(0.9);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .tree-node.kingdom {
            background: linear-gradient(135deg, #ff6b6b, #ee5a6f);
            color: white;
            font-size: 1em;
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(255, 107, 107, 0.4);
        }

        .tree-node.phylum {
            background: linear-gradient(135deg, #f06595, #e64980);
            color: white;
            box-shadow: 0 3px 8px rgba(240, 101, 149, 0.4);
        }

        .tree-node.class {
            background: linear-gradient(135deg, #cc5de8, #be4bdb);
            color: white;
            box-shadow: 0 3px 8px rgba(204, 93, 232, 0.4);
        }

        .tree-node.order {
            background: linear-gradient(135deg, #748ffc, #5c7cfa);
            color: white;
            box-shadow: 0 3px 8px rgba(116, 143, 252, 0.4);
        }

        .tree-node.family {
            background: linear-gradient(135deg, #4dabf7, #339af0);
            color: white;
            box-shadow: 0 3px 8px rgba(77, 171, 247, 0.4);
        }

        .tree-node.genus {
            background: linear-gradient(135deg, #38d9a9, #20c997);
            color: white;
            box-shadow: 0 3px 8px rgba(56, 217, 169, 0.4);
        }

        .tree-node.species {
            background: linear-gradient(135deg, #82c91e, #5c940d);
            color: white;
            box-shadow: 0 3px 8px rgba(130, 201, 30, 0.4);
        }

        .tree-node.target {
            background: linear-gradient(135deg, #ffd43b, #fab005);
            color: #333;
            font-weight: bold;
            box-shadow: 0 4px 12px rgba(255, 212, 59, 0.6);
        }

        .tree-node.mystery {
            background: linear-gradient(135deg, #868e96, #495057);
            color: white;
            border: 3px dashed white;
            font-size: 1.2em;
            font-weight: bold;
        }

        .level-label {
            font-size: 0.65em;
            text-transform: uppercase;
            opacity: 0.7;
            margin-bottom: 5px;
            letter-spacing: 0.5px;
            color: #666;
            font-weight: 600;
            text-align: center;
        }

        /* Modals */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 15px;
            padding: 30px;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #52c234;
        }

        .modal-header h2 {
            color: #2d7a1f;
            margin: 0;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 2em;
            color: #666;
            cursor: pointer;
            padding: 0;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background-color 0.2s;
        }

        .close-btn:hover {
            background: #f0f0f0;
        }

        .game-over {
            text-align: center;
            padding: 20px;
        }

        .game-over h3 {
            color: #2d7a1f;
            font-size: 1.5em;
            margin-bottom: 15px;
        }

        .game-over p {
            margin: 10px 0;
        }

        .new-game-btn {
            background: #28a745;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            margin-top: 15px;
        }

        .new-game-btn:hover {
            background: #218838;
        }

        .loading {
            text-align: center;
            padding: 40px;
            font-size: 1.2em;
            color: white;
        }

        /* Responsive */
        @media (min-width: 768px) {
            .header h1 {
                font-size: 2em;
            }

            .tree-node {
                padding: 10px 16px;
                min-width: 100px;
                font-size: 1em;
            }
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading" class="loading">Loading animal kingdom...</div>

    <!-- Main Game (hidden initially) -->
    <div id="gameContainer" style="display: none; height: 100vh; flex-direction: column;">
        <!-- Header -->
        <div class="header">
            <div class="header-left">
                <button class="icon-btn" onclick="toggleMenu()" title="Menu">‚ò∞</button>
            </div>
            <div class="header-center">
                <h1>üåø Taxonle</h1>
            </div>
            <div class="header-right">
                <span class="guess-counter" id="guessCount">0/20</span>
                <button class="icon-btn" onclick="openHelp()" title="Help">‚ùì</button>
            </div>
        </div>

        <!-- Tree Area -->
        <div class="tree-area">
            <div class="tree-container" id="treeDisplay">
                <div class="empty-tree">
                    <div class="empty-tree-icon">üå±</div>
                    <div class="empty-tree-text">Start guessing to reveal the tree!</div>
                </div>
            </div>
        </div>

        <!-- Input Bar -->
        <div class="input-bar">
            <div class="search-wrapper">
                <input
                    type="text"
                    id="guessInput"
                    placeholder="Type an animal name..."
                    autocomplete="off"
                >
                <div id="autocompleteList" class="autocomplete-list"></div>
            </div>
            <button class="submit-btn" id="guessBtn" onclick="makeGuess()">Submit</button>
        </div>
    </div>

    <!-- Slide-out Menu -->
    <div class="menu-overlay" id="menuOverlay" onclick="toggleMenu()"></div>
    <div class="menu-panel" id="menuPanel">
        <div class="menu-header">
            <h2>Menu</h2>
            <button class="icon-btn" onclick="toggleMenu()">&times;</button>
        </div>

        <div class="menu-section">
            <div class="menu-items">
                <button class="menu-btn primary" onclick="startNewGame(); toggleMenu();">üîÑ New Game</button>
                <button class="menu-btn danger" onclick="giveUp(); toggleMenu();">üè≥Ô∏è Give Up</button>
                <button class="menu-btn settings" onclick="openSettings(); toggleMenu();">‚öôÔ∏è Settings</button>
            </div>
        </div>

        <div class="menu-section">
            <h3>Stats</h3>
            <div style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
                <div style="margin-bottom: 10px;">
                    <strong>Path Revealed:</strong> <span id="pathDepth">0 / 7</span>
                </div>
                <div>
                    <strong>Database Size:</strong> <span id="totalAnimals">0</span>
                </div>
            </div>
        </div>

        <div class="menu-section">
            <h3>Hints</h3>
            <button class="menu-btn" id="hintBtnMenu" onclick="showHint(); toggleMenu();">
                üí° Hint (Locked)
            </button>
            <div id="hintsArea"></div>
        </div>
    </div>

    <!-- Help Modal (same as before) -->
    <div id="helpModal" class="modal-overlay" onclick="closeHelpIfOutside(event)">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-header">
                <h2>‚ùì How to Play</h2>
                <button class="close-btn" onclick="closeHelp()">&times;</button>
            </div>
            <div style="line-height: 1.6;">
    </style>
</head>
<body>
                <h4 style="color: #2d7a1f; margin-bottom: 10px;">How It Works</h4>
                <p>‚Ä¢ Each guess reveals how much taxonomy you share with the mystery animal</p>
                <p>‚Ä¢ The tree shows the shared taxonomic path</p>
                <p>‚Ä¢ Closer guesses reveal deeper levels (Kingdom ‚Üí Phylum ‚Üí Class ‚Üí Order ‚Üí Family ‚Üí Genus ‚Üí Species)</p>
                <p>‚Ä¢ Animals appear at their divergence point on the tree</p>
                <p>‚Ä¢ The ??? marker shows where the mystery animal branches off</p>

                <h4 style="color: #2d7a1f; margin-bottom: 10px; margin-top: 15px;">Hints</h4>
                <p>‚Ä¢ Hint 1 unlocks at 5 guesses (Conservation Status)</p>
                <p>‚Ä¢ Hint 2 unlocks at 10 guesses (Geographic Distribution)</p>

                <h4 style="color: #2d7a1f; margin-bottom: 10px; margin-top: 15px;">Tips</h4>
                <p>‚Ä¢ Start with broad guesses to narrow down the phylum/class</p>
                <p>‚Ä¢ Use the autocomplete to find animals quickly</p>
                <p>‚Ä¢ Watch the tree structure to guide your next guess</p>
            </div>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div id="gameOverModal" class="modal-overlay">
        <div class="modal-content" onclick="event.stopPropagation()" style="text-align: center;">
            <div id="gameOverContent"></div>
        </div>
    </div>

    <!-- Settings Modal (placeholder) -->
    <div id="settingsModal" class="modal-overlay" onclick="closeSettingsIfOutside(event)">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-header">
                <h2>‚öôÔ∏è Settings</h2>
                <button class="close-btn" onclick="closeSettings()">&times;</button>
            </div>
            <p>Settings coming soon...</p>
        </div>
    </div>

    <script src="game.js"></script>
</body>
</html>

    <script>

        // Menu toggle
        function toggleMenu() {
            const menuPanel = document.getElementById('menuPanel');
            const menuOverlay = document.getElementById('menuOverlay');
            menuPanel.classList.toggle('active');
            menuOverlay.classList.toggle('active');
        }

        let animals = [];
        let targetAnimal = null;
        let guesses = [];
        let guessCount = 0;
        const maxGuesses = 20;
        let gameOver = false;

        // Tree structure to track revealed nodes
        const revealedTree = {
            kingdom: null,
            phylum: new Set(),
            class: new Set(),
            order: new Set(),
            family: new Set(),
            genus: new Set(),
            species: new Set()
        };

        let deepestLevel = 0;

        // Track disabled taxonomy paths
        let disabledPaths = new Set();
        let pendingDisabledPaths = new Set();

        // Hint system
        let hintsUsed = 0;
        const maxHints = 2;

        // Load animals data
        async function loadAnimals() {
            try {
                const response = await fetch('animals_data.json');
                animals = await response.json();
                updateAnimalCount();
                startNewGame();
                document.getElementById('loading').style.display = 'none';
                document.getElementById('gameContainer').style.display = 'flex';
            } catch (error) {
                document.getElementById('loading').textContent = 'Error loading data. Please refresh.';
                console.error('Error loading animals:', error);
            }
        }

        function startNewGame() {
            const availableAnimals = getFilteredAnimals();
            if (availableAnimals.length === 0) {
                alert('No animals available with current filter settings!');
                return;
            }
            targetAnimal = availableAnimals[Math.floor(Math.random() * availableAnimals.length)];
            guesses = [];
            guessCount = 0;
            gameOver = false;
            deepestLevel = 0;

            // Reset tree
            revealedTree.kingdom = null;
            revealedTree.phylum = new Set();
            revealedTree.class = new Set();
            revealedTree.order = new Set();
            revealedTree.family = new Set();
            revealedTree.genus = new Set();
            revealedTree.species = new Set();

            updateStats();
            renderTree();
            // messageArea removed in new design;
            document.getElementById('guessInput').value = '';
            document.getElementById('guessInput').disabled = false;
            document.getElementById('guessBtn').disabled = false;
            document.getElementById('giveUpBtn').disabled = false;
            document.getElementById('retryBtn').disabled = false;

            // Reset hints
            hintsUsed = 0;
            document.getElementById('hintsArea').innerHTML = '';
            updateHintButton();

            console.log('Target:', targetAnimal);
        }

        // Update hint button state
        function updateHintButton() {
            const hintBtn = document.getElementById('hintBtnMenu');
            const availableHints = Math.floor(guessCount / 5);
            const hintsAvailable = Math.min(availableHints, maxHints) - hintsUsed;

            if (hintsAvailable > 0 && !gameOver) {
                hintBtn.textContent = `üí° Hint (${hintsAvailable} available)`;
                hintBtn.disabled = false;
                hintBtn.style.opacity = '1';
            } else if (hintsUsed >= maxHints) {
                hintBtn.textContent = 'üí° No more hints';
                hintBtn.disabled = true;
                hintBtn.style.opacity = '0.5';
            } else {
                const nextHintAt = (Math.floor(hintsUsed / 1) + 1) * 5;
                hintBtn.textContent = `üí° Hint (Next at ${nextHintAt} guesses)`;
                hintBtn.disabled = true;
                hintBtn.style.opacity = '0.5';
            }
        }

        // Show hint
        function showHint() {
            if (gameOver) return;

            const availableHints = Math.floor(guessCount / 5);
            if (hintsUsed >= availableHints || hintsUsed >= maxHints) {
                return;
            }

            const hintsArea = document.getElementById('hintsArea');

            if (hintsUsed === 0) {
                // First hint: Threat Status
                const hintBox = document.createElement('div');
                hintBox.className = 'hint-box';
                hintBox.innerHTML = `
                    <h4>Hint 1: Conservation Status</h4>
                    <p>${targetAnimal.threatStatus || 'Unknown'}</p>
                `;
                hintsArea.appendChild(hintBox);
            } else if (hintsUsed === 1) {
                // Second hint: Distribution
                const hintBox = document.createElement('div');
                hintBox.className = 'hint-box';
                hintBox.innerHTML = `
                    <h4>Hint 2: Geographic Distribution</h4>
                    <p>${targetAnimal.distribution || 'Unknown'}</p>
                `;
                hintsArea.appendChild(hintBox);
            }

            hintsUsed++;
            updateHintButton();
        }

        // Autocomplete functionality
        const guessInput = document.getElementById('guessInput');
        const autocompleteList = document.getElementById('autocompleteList');

        guessInput.addEventListener('input', function() {
            const searchTerm = this.value.toLowerCase().trim();

            if (searchTerm.length < 2) {
                autocompleteList.style.display = 'none';
                return;
            }

            const matches = getFilteredAnimals()
                .filter(animal =>
                    animal.commonName.toLowerCase().includes(searchTerm) ||
                    animal.scientificName.toLowerCase().includes(searchTerm)
                )
                .slice(0, 15);

            if (matches.length > 0) {
                autocompleteList.innerHTML = matches.map(animal => `
                    <div class="autocomplete-item" onclick="selectAnimal('${escapeHtml(animal.commonName)}')">
                        <div class="autocomplete-item-name">${escapeHtml(animal.commonName)}</div>
                        <div class="autocomplete-item-scientific">${escapeHtml(animal.scientificName)}</div>
                    </div>
                `).join('');
                autocompleteList.style.display = 'block';
            } else {
                autocompleteList.style.display = 'none';
            }
        });

        document.addEventListener('click', function(e) {
            if (!e.target.closest('.search-wrapper')) {
                autocompleteList.style.display = 'none';
            }
        });

        function selectAnimal(name) {
            guessInput.value = name;
            autocompleteList.style.display = 'none';
        }

        guessInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                makeGuess();
            }
        });

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Make a guess
        function makeGuess() {
            if (gameOver) return;

            const input = guessInput.value.trim();
            if (!input) {
                showMessage('Please enter an animal name!', 'error');
                return;
            }

            // Find the animal
            const animal = getFilteredAnimals().find(a =>
                a.commonName.toLowerCase() === input.toLowerCase() ||
                a.scientificName.toLowerCase() === input.toLowerCase()
            );

            if (!animal) {
                showMessage('Animal not available. Check filter settings!', 'error');
                return;
            }

            // Check if already guessed
            if (guesses.some(g => g.scientificName === animal.scientificName)) {
                showMessage('You already guessed this species!', 'info');
                return;
            }

            // Add to guesses
            guesses.push(animal);
            guessCount++;

            // Compare with target and update tree
            const commonLevel = compareWithTarget(animal);

            // Update stats
            updateStats();

            // Update hint button
            updateHintButton();

            // Check if won
            if (animal.scientificName === targetAnimal.scientificName) {
                winGame();
                return;
            }

            // Check if lost
            if (guessCount >= maxGuesses) {
                loseGame();
                return;
            }

            // Clear input
            guessInput.value = '';
            guessInput.focus();
        }

        // Compare guessed animal with target
        function compareWithTarget(guessedAnimal) {
            const levels = ['kingdom', 'phylum', 'class', 'order', 'family', 'genus', 'species'];
            let commonLevel = -1;

            // Always set kingdom to Animalia
            revealedTree.kingdom = 'Animalia';

            // Find deepest common level
            for (let i = 0; i < levels.length; i++) {
                const level = levels[i];
                let guessValue, targetValue;

                if (level === 'kingdom') {
                    guessValue = 'Animalia';
                    targetValue = 'Animalia';
                } else if (level === 'species') {
                    guessValue = guessedAnimal.scientificName;
                    targetValue = targetAnimal.scientificName;
                } else {
                    guessValue = guessedAnimal[level];
                    targetValue = targetAnimal[level];
                }

                if (guessValue && targetValue &&
                    guessValue.toLowerCase() === targetValue.toLowerCase()) {
                    commonLevel = i;

                    // Add to revealed tree
                    if (level !== 'kingdom') {
                        revealedTree[level].add(guessValue);
                    }
                } else {
                    break; // Stop at first divergence
                }
            }

            // Update deepest level revealed
            if (commonLevel > deepestLevel) {
                deepestLevel = commonLevel;
            }

            renderTree();

            const levelName = commonLevel >= 0 ? levels[commonLevel] : 'none';
            return levelName;
        }

        // Build simplified tree showing only shared path and divergence points
        function buildTreeStructure() {
            const levels = ['kingdom', 'phylum', 'class', 'order', 'family', 'genus', 'species'];

            // Build the shared path up to deepestLevel
            const tree = {};
            const pathNodes = []; // Track nodes at each level for placing animals

            let currentNode = tree;

            // Build the common path
            for (let i = 0; i <= deepestLevel; i++) {
                const level = levels[i];
                let value;

                if (level === 'kingdom') {
                    value = 'Animalia';
                } else if (level === 'species') {
                    value = targetAnimal.scientificName;
                } else {
                    value = targetAnimal[level];
                }

                if (value) {
                    currentNode[value] = {
                        name: value,
                        level: level,
                        levelIndex: i,
                        children: {},
                        isSharedPath: true
                    };
                    pathNodes[i] = currentNode[value].children;
                    currentNode = currentNode[value].children;
                }
            }

            // Collect animals by their divergence level
            const animalsByLevel = {};

            guesses.forEach(animal => {
                // Find how deep this animal matches with target
                let animalDepth = 0;
                for (let i = 0; i < levels.length; i++) {
                    const level = levels[i];
                    let guessValue, targetValue;

                    if (level === 'kingdom') {
                        guessValue = 'Animalia';
                        targetValue = 'Animalia';
                    } else if (level === 'species') {
                        guessValue = animal.scientificName;
                        targetValue = targetAnimal.scientificName;
                    } else {
                        guessValue = animal[level];
                        targetValue = targetAnimal[level];
                    }

                    if (guessValue && targetValue &&
                        guessValue.toLowerCase() === targetValue.toLowerCase()) {
                        animalDepth = i;
                    } else {
                        break;
                    }
                }

                if (!animalsByLevel[animalDepth]) {
                    animalsByLevel[animalDepth] = [];
                }
                animalsByLevel[animalDepth].push(animal);
            });

            // Place animals at their divergence points with mystery in the middle at deepest level
            Object.keys(animalsByLevel).forEach(depthStr => {
                const depth = parseInt(depthStr);
                const animalsAtDepth = animalsByLevel[depth];

                if (depth === deepestLevel && !gameOver && deepestLevel < 6) {
                    // Insert mystery in the middle for the deepest level
                    const midPoint = Math.floor(animalsAtDepth.length / 2);

                    animalsAtDepth.forEach((animal, idx) => {
                        if (idx === midPoint) {
                            // Add mystery first
                            pathNodes[depth]['mystery'] = {
                                name: '???',
                                level: 'animal',
                                levelIndex: depth + 1,
                                children: {},
                                mystery: true
                            };
                        }

                        const animalKey = `animal_${animal.commonName}_${idx}`;
                        pathNodes[depth][animalKey] = {
                            name: animal.commonName,
                            scientificName: animal.scientificName,
                            level: 'animal',
                            levelIndex: depth + 1,
                            children: {},
                            animal: animal
                        };
                    });
                } else {
                    // Normal placement for other levels
                    animalsAtDepth.forEach((animal, idx) => {
                        const animalKey = `animal_${animal.commonName}_${idx}`;
                        pathNodes[depth][animalKey] = {
                            name: animal.commonName,
                            scientificName: animal.scientificName,
                            level: 'animal',
                            levelIndex: depth + 1,
                            children: {},
                            animal: animal
                        };
                    });
                }
            });

            return tree;
        }

        // Generate unique ID for each node
        let nodeIdCounter = 0;
        function generateNodeId() {
            return `node-${nodeIdCounter++}`;
        }

        // Render tree recursively with top-down branching
        function renderTreeNode(node, levelIdx) {
            const levelClasses = ['kingdom', 'phylum', 'class', 'order', 'family', 'genus', 'species'];
            const levelLabels = ['Kingdom', 'Phylum', 'Class', 'Order', 'Family', 'Genus', 'Species'];

            const nodeId = generateNodeId();
            node.id = nodeId;

            let html = '<div class="tree-branch-group">';

            // Node itself
            html += `<div class="tree-node-wrapper" id="${nodeId}">`;

            // Only show level label for shared path nodes (not for animal nodes)
            if (node.isSharedPath) {
                const label = levelLabels[levelIdx];
                html += '<div class="level-label">' + label + '</div>';
                const cssClass = levelClasses[levelIdx];
                html += `<div class="tree-node ${cssClass}">${node.name}</div>`;
            } else if (node.mystery) {
                // Mystery placeholder at divergence point
                html += '<div class="tree-node mystery">???</div>';
            } else if (node.level === 'animal') {
                // Animal node at divergence point (no level label)
                const isTarget = gameOver && node.animal && node.animal.scientificName === targetAnimal.scientificName;
                const cssClass = isTarget ? 'target' : 'species';
                const title = node.scientificName || '';
                html += `<div class="tree-node ${cssClass}" title="${title}">
                    ${node.name}
                </div>`;
            }

            html += '</div>'; // close tree-node-wrapper

            // Render children
            const children = Object.values(node.children);
            if (children.length > 0) {
                html += '<div class="tree-children">';
                children.forEach((child) => {
                    html += renderTreeNode(child, child.levelIndex);
                });
                html += '</div>';
            }

            html += '</div>'; // close tree-branch-group
            return html;
        }

        // Draw smooth SVG connections between nodes
        function drawConnections() {
            const container = document.getElementById('treeDisplay');
            const existingSvg = container.querySelector('.tree-svg');
            if (existingSvg) {
                existingSvg.remove();
            }

            // Get the actual scrollable content area
            const treeContent = container.querySelector('.tree-content');
            if (!treeContent) return;

            const containerRect = container.getBoundingClientRect();
            const contentRect = treeContent.getBoundingClientRect();

            // Create SVG with proper dimensions
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('class', 'tree-svg');

            // Calculate proper SVG dimensions
            const svgWidth = Math.max(contentRect.width, containerRect.width);
            const svgHeight = Math.max(contentRect.height, containerRect.height);

            svg.setAttribute('width', svgWidth);
            svg.setAttribute('height', svgHeight);
            svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
            svg.style.position = 'absolute';
            svg.style.top = '0';
            svg.style.left = '0';
            svg.style.pointerEvents = 'none';
            svg.style.zIndex = '1';
            svg.style.overflow = 'visible';

            // Find all nodes and draw connections to their children
            const allNodes = container.querySelectorAll('.tree-node-wrapper');

            allNodes.forEach(parentNode => {
                const parentRect = parentNode.getBoundingClientRect();
                const parentX = parentRect.left + parentRect.width / 2 - containerRect.left;
                const parentY = parentRect.bottom - containerRect.top;

                // Find children
                const parentGroup = parentNode.closest('.tree-branch-group');
                const childrenContainer = parentGroup.querySelector(':scope > .tree-children');

                if (childrenContainer) {
                    const childWrappers = childrenContainer.querySelectorAll(':scope > .tree-branch-group > .tree-node-wrapper');

                    childWrappers.forEach(childNode => {
                        const childRect = childNode.getBoundingClientRect();
                        const childX = childRect.left + childRect.width / 2 - containerRect.left;
                        const childY = childRect.top - containerRect.top;

                        // Create smooth curved path
                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');

                        // Calculate control points for smooth curve
                        const midY = parentY + (childY - parentY) * 0.5;

                        const pathData = `M ${parentX} ${parentY} C ${parentX} ${midY}, ${childX} ${midY}, ${childX} ${childY}`;

                        path.setAttribute('d', pathData);
                        path.setAttribute('stroke', '#52c234');
                        path.setAttribute('stroke-width', '3');
                        path.setAttribute('fill', 'none');
                        path.setAttribute('opacity', '0.7');
                        path.setAttribute('stroke-linecap', 'round');

                        svg.appendChild(path);
                    });
                }
            });

            container.insertBefore(svg, container.firstChild);
        }

        // Render the tree
        function renderTree() {
            const treeDisplay = document.getElementById('treeDisplay');
            nodeIdCounter = 0;

            if (guesses.length === 0) {
                treeDisplay.innerHTML = `
                    <div class="empty-tree">
                        <div class="empty-tree-icon">üå±</div>
                        <div class="empty-tree-text">Start guessing to reveal the tree!</div>
                    </div>
                `;
                return;
            }

            const tree = buildTreeStructure();
            let html = '<div class="tree-content"><div class="tree-root">';

            // Render from root (should only be Animalia)
            Object.values(tree).forEach(rootNode => {
                html += renderTreeNode(rootNode, rootNode.levelIndex);
            });

            html += '</div></div>';
            treeDisplay.innerHTML = html;

            // Draw connections after DOM is updated
            requestAnimationFrame(() => {
                setTimeout(() => {
                    drawConnections();
                }, 100);
            });
        }

        // Update statistics
        function updateStats() {
            document.getElementById('guessCount').textContent = `${guessCount} / ${maxGuesses}`;
            document.getElementById('pathDepth').textContent = `${deepestLevel} / 7`;
        }

        // Show message
        function showMessage(text, type = 'info') {
            const messageArea = document.getElementById('messageArea');
            messageArea.innerHTML = `<div class="message ${type}">${text}</div>`;

            setTimeout(() => {
                messageArea.innerHTML = '';
            }, 3000);
        }

        // Win game
        function winGame() {
            gameOver = true;
            guessInput.disabled = true;
            document.getElementById('guessBtn').disabled = true;
            document.getElementById('giveUpBtn').disabled = true;
            document.getElementById('retryBtn').disabled = true;
            document.getElementById('hintBtnMenu').disabled = true;

            const gameOverContent = document.getElementById('gameOverContent');
            gameOverContent.innerHTML = `
                <div class="game-over">
                    <h3>üéâ You Found It!</h3>
                    <p><strong>${targetAnimal.commonName}</strong></p>
                    <p><em>${targetAnimal.scientificName}</em></p>
                    <p>Guessed in ${guessCount} ${guessCount === 1 ? 'try' : 'tries'}!</p>
                    <button class="new-game-btn" onclick="closeGameOver(); startNewGame();">Play Again</button>
                </div>
            `;
            document.getElementById('gameOverModal').classList.add('active');
        }

        // Lose game
        function loseGame() {
            gameOver = true;
            guessInput.disabled = true;
            document.getElementById('guessBtn').disabled = true;
            document.getElementById('giveUpBtn').disabled = true;
            document.getElementById('retryBtn').disabled = true;
            document.getElementById('hintBtnMenu').disabled = true;

            const gameOverContent = document.getElementById('gameOverContent');
            gameOverContent.innerHTML = `
                <div class="game-over">
                    <h3>Game Over!</h3>
                    <p>The answer was:</p>
                    <p><strong>${targetAnimal.commonName}</strong></p>
                    <p><em>${targetAnimal.scientificName}</em></p>
                    <button class="new-game-btn" onclick="closeGameOver(); startNewGame();">Try Again</button>
                </div>
            `;
            document.getElementById('gameOverModal').classList.add('active');
        }

        // Give up
        function giveUp() {
            if (gameOver) return;

            if (!confirm('Are you sure you want to give up and see the answer?')) {
                return;
            }

            gameOver = true;
            guessInput.disabled = true;
            document.getElementById('guessBtn').disabled = true;
            document.getElementById('giveUpBtn').disabled = true;
            document.getElementById('retryBtn').disabled = true;
            document.getElementById('hintBtnMenu').disabled = true;

            // Reveal the target in the tree by setting deepest level to 6
            deepestLevel = 6;

            // Add target to guesses to show it in the tree
            if (!guesses.some(g => g.scientificName === targetAnimal.scientificName)) {
                guesses.push(targetAnimal);
            }

            renderTree();

            const gameOverContent = document.getElementById('gameOverContent');
            gameOverContent.innerHTML = `
                <div class="game-over">
                    <h3>You Gave Up!</h3>
                    <p>The answer was:</p>
                    <p><strong>${targetAnimal.commonName}</strong></p>
                    <p><em>${targetAnimal.scientificName}</em></p>
                    <p>Better luck next time!</p>
                    <button class="new-game-btn" onclick="closeGameOver(); startNewGame();">Try Again</button>
                </div>
            `;
            document.getElementById('gameOverModal').classList.add('active');
        }

        // Redraw connections on window resize
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (guesses.length > 0) {
                    drawConnections();
                }
            }, 100);
        });

        // Settings Modal Functions
        function openSettings() {
            // Copy active settings to pending
            pendingDisabledPaths = new Set(disabledPaths);
            buildFilterTree();
            document.getElementById('settingsModal').classList.add('active');
        }

        function closeSettings() {
            document.getElementById('settingsModal').classList.remove('active');
        }

        function applyFilterSettings() {
            // Apply pending changes to active
            disabledPaths = new Set(pendingDisabledPaths);
            updateAnimalCount();
            closeSettings();
            startNewGame();
        }

        function closeSettingsIfOutside(event) {
            if (event.target.id === 'settingsModal') {
                closeSettings();
            }
        }

        // Help Modal Functions
        function openHelp() {
            document.getElementById('helpModal').classList.add('active');
        }

        function closeHelp() {
            document.getElementById('helpModal').classList.remove('active');
        }

        function closeHelpIfOutside(event) {
            if (event.target.id === 'helpModal') {
                closeHelp();
            }
        }

        // Game Over Modal Functions
        function closeGameOver() {
            document.getElementById('gameOverModal').classList.remove('active');
        }

        // Build taxonomy filter tree (top 3 levels: Kingdom, Phylum, Class)
        function buildFilterTree() {
            const tree = {};

            animals.forEach(animal => {
                const phylum = animal.phylum || 'Unknown';
                const className = animal.class || 'Unknown';

                if (!tree[phylum]) {
                    tree[phylum] = new Set();
                }
                tree[phylum].add(className);
            });

            renderFilterTree(tree);
        }

        // Render the filter tree in the modal
        function renderFilterTree(tree) {
            const container = document.getElementById('filterTree');
            let html = '<div class="filter-tree-node">';

            // Kingdom (always Animalia)
            html += '<div class="filter-node-content filter-node-phylum" style="background: linear-gradient(135deg, #ff6b6b, #ee5a6f);">Animalia (Kingdom)</div>';

            // Phyla and Classes
            const sortedPhyla = Object.keys(tree).sort();
            sortedPhyla.forEach(phylum => {
                const phylumPath = `phylum:${phylum}`;
                const phylumDisabled = pendingDisabledPaths.has(phylumPath);

                html += '<div class="filter-children">';
                html += `<div class="filter-tree-node">`;
                html += `<div class="filter-node-content filter-node-phylum ${phylumDisabled ? 'disabled' : ''}"
                         onclick="toggleTaxonomyPath('${phylumPath}')">
                         ${phylum}
                         </div>`;

                // Classes under this phylum
                const sortedClasses = Array.from(tree[phylum]).sort();
                if (sortedClasses.length > 0) {
                    html += '<div class="filter-children">';
                    sortedClasses.forEach(className => {
                        const classPath = `phylum:${phylum}|class:${className}`;
                        const classDisabled = pendingDisabledPaths.has(classPath) || phylumDisabled;

                        html += `<div class="filter-tree-node">`;
                        html += `<div class="filter-node-content filter-node-class ${classDisabled ? 'disabled' : ''}"
                                 onclick="toggleTaxonomyPath('${classPath}', '${phylumPath}')">
                                 ${className}
                                 </div>`;
                        html += '</div>';
                    });
                    html += '</div>';
                }

                html += '</div>';
                html += '</div>';
            });

            html += '</div>';
            container.innerHTML = html;
        }

        // Toggle taxonomy path on/off (modifies pending changes only)
        function toggleTaxonomyPath(path, parentPath) {
            if (pendingDisabledPaths.has(path)) {
                // Enable this path and all children
                const pathsToRemove = Array.from(pendingDisabledPaths).filter(p => p === path || p.startsWith(path + '|'));
                pathsToRemove.forEach(p => pendingDisabledPaths.delete(p));
            } else {
                // Disable this path (children will be implicitly disabled)
                pendingDisabledPaths.add(path);

                // If parent is disabled, we don't need to explicitly disable children
                if (parentPath && pendingDisabledPaths.has(parentPath)) {
                    pendingDisabledPaths.delete(path);
                }
            }

            buildFilterTree();
        }

        // Filter animals based on disabled paths
        function getFilteredAnimals() {
            if (!animals || animals.length === 0) {
                return [];
            }

            if (disabledPaths.size === 0) {
                return animals;
            }

            return animals.filter(animal => {
                const phylum = animal.phylum || 'Unknown';
                const className = animal.class || 'Unknown';

                const phylumPath = `phylum:${phylum}`;
                const classPath = `phylum:${phylum}|class:${className}`;

                // If phylum is disabled, exclude
                if (disabledPaths.has(phylumPath)) {
                    return false;
                }

                // If class is disabled, exclude
                if (disabledPaths.has(classPath)) {
                    return false;
                }

                return true;
            });
        }

        // Update animal count in stats
        function updateAnimalCount() {
            const filteredCount = getFilteredAnimals().length;
            document.getElementById('totalAnimals').textContent = filteredCount;
        }

        // Initialize
        loadAnimals();
    </script>
</body>
</html>
