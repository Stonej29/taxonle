<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Taxonle - Discover the Animal Kingdom</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #52c234 0%, #a8d530 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 20px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
        }

        .header .subtitle {
            font-size: 1.2em;
            opacity: 0.95;
        }

        .game-container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 20px;
        }

        .left-panel {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            height: fit-content;
            position: sticky;
            top: 20px;
        }

        .stats {
            margin-bottom: 25px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 12px 0;
            border-bottom: 1px solid #eee;
        }

        .stat-item:last-child {
            border-bottom: none;
        }

        .stat-label {
            font-weight: 600;
            color: #666;
        }

        .stat-value {
            font-weight: bold;
            font-size: 1.2em;
            color: #2d7a1f;
        }

        .input-section {
            margin-bottom: 20px;
        }

        .input-section h3 {
            color: #2d7a1f;
            margin-bottom: 15px;
        }

        .search-wrapper {
            position: relative;
            margin-bottom: 15px;
        }

        input[type="text"] {
            width: 100%;
            padding: 12px;
            font-size: 1em;
            border: 2px solid #ddd;
            border-radius: 8px;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #52c234;
        }

        .autocomplete-list {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid #52c234;
            border-top: none;
            border-radius: 0 0 8px 8px;
            max-height: 250px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .autocomplete-item {
            padding: 10px 12px;
            cursor: pointer;
            transition: background-color 0.2s;
            border-bottom: 1px solid #f0f0f0;
        }

        .autocomplete-item:hover {
            background-color: #f0fff0;
        }

        .autocomplete-item-name {
            font-weight: bold;
            color: #333;
        }

        .autocomplete-item-scientific {
            font-size: 0.85em;
            color: #666;
            font-style: italic;
            margin-top: 2px;
        }

        button {
            width: 100%;
            padding: 12px;
            font-size: 1em;
            background: #52c234;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s;
            font-weight: bold;
        }

        button:hover {
            background: #3da328;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .instructions {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            font-size: 0.9em;
            line-height: 1.6;
        }

        .instructions h4 {
            color: #2d7a1f;
            margin-bottom: 10px;
        }

        .tree-panel {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            min-height: 600px;
            overflow: auto;
        }

        .tree-header {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #52c234;
        }

        .tree-header h2 {
            color: #2d7a1f;
            font-size: 1.8em;
        }

        .tree-container {
            padding: 40px 20px;
            overflow-x: auto;
            overflow-y: visible;
            min-height: 600px;
            position: relative;
        }

        .tree-svg {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 1;
            overflow: visible;
        }

        .tree-content {
            position: relative;
            z-index: 2;
        }

        .tree-root {
            display: inline-flex;
            justify-content: center;
            width: 100%;
        }

        .tree-branch-group {
            display: inline-flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            margin: 0 20px;
        }

        .tree-children {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            gap: 15px;
            margin-top: 50px;
            flex-wrap: nowrap;
        }

        .tree-node-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }

        .tree-node {
            display: inline-block;
            padding: 10px 16px;
            border-radius: 8px;
            font-weight: 500;
            min-width: 100px;
            text-align: center;
            position: relative;
            animation: fadeIn 0.5s ease-out;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .tree-node:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: scale(0.9);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .tree-node.kingdom {
            background: linear-gradient(135deg, #ff6b6b, #ee5a6f);
            color: white;
            font-size: 1.2em;
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(255, 107, 107, 0.4);
        }

        .tree-node.phylum {
            background: linear-gradient(135deg, #f06595, #e64980);
            color: white;
            box-shadow: 0 3px 8px rgba(240, 101, 149, 0.4);
        }

        .tree-node.class {
            background: linear-gradient(135deg, #cc5de8, #be4bdb);
            color: white;
            box-shadow: 0 3px 8px rgba(204, 93, 232, 0.4);
        }

        .tree-node.order {
            background: linear-gradient(135deg, #748ffc, #5c7cfa);
            color: white;
            box-shadow: 0 3px 8px rgba(116, 143, 252, 0.4);
        }

        .tree-node.family {
            background: linear-gradient(135deg, #4dabf7, #339af0);
            color: white;
            box-shadow: 0 3px 8px rgba(77, 171, 247, 0.4);
        }

        .tree-node.genus {
            background: linear-gradient(135deg, #38d9a9, #20c997);
            color: white;
            box-shadow: 0 3px 8px rgba(56, 217, 169, 0.4);
        }

        .tree-node.species {
            background: linear-gradient(135deg, #69db7c, #51cf66);
            color: white;
            font-weight: bold;
            font-size: 1.1em;
            box-shadow: 0 3px 8px rgba(105, 219, 124, 0.4);
        }

        .tree-node.target {
            background: linear-gradient(135deg, #ffd43b, #fab005);
            color: #333;
            font-weight: bold;
            font-size: 1.15em;
            box-shadow: 0 4px 12px rgba(255, 212, 59, 0.5);
            border: 3px solid #f59f00;
        }

        .tree-node.mystery {
            background: linear-gradient(135deg, #868e96, #495057);
            color: white;
            font-weight: bold;
            font-size: 1.15em;
            box-shadow: 0 4px 12px rgba(73, 80, 87, 0.5);
            border: 3px dashed #212529;
        }

        .empty-tree {
            text-align: center;
            padding: 80px 20px;
            color: #999;
        }

        .empty-tree-icon {
            font-size: 5em;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        .empty-tree-text {
            font-size: 1.3em;
        }

        .message {
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 8px;
            text-align: center;
            font-weight: 500;
            animation: slideDown 0.3s ease-out;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message.success {
            background: #d4edda;
            color: #155724;
            border: 2px solid #28a745;
        }

        .message.error {
            background: #f8d7da;
            color: #721c24;
            border: 2px solid #dc3545;
        }

        .message.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 2px solid #17a2b8;
        }

        .game-over {
            text-align: center;
            padding: 30px;
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .game-over h3 {
            color: #856404;
            font-size: 1.5em;
            margin-bottom: 15px;
        }

        .new-game-btn {
            background: #28a745;
            margin-top: 15px;
        }

        .new-game-btn:hover {
            background: #218838;
        }

        .loading {
            text-align: center;
            padding: 40px;
            font-size: 1.2em;
            color: white;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .button-group button {
            flex: 1;
        }

        .level-label {
            font-size: 0.7em;
            text-transform: uppercase;
            opacity: 0.7;
            margin-bottom: 5px;
            letter-spacing: 0.5px;
            color: #666;
            font-weight: 600;
            text-align: center;
        }

        .settings-btn {
            background: #6c757d;
            margin-top: 15px;
            padding: 10px;
            font-size: 0.9em;
        }

        .settings-btn:hover {
            background: #5a6268;
        }

        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 15px;
            padding: 30px;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #52c234;
        }

        .modal-header h2 {
            color: #2d7a1f;
            margin: 0;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 2em;
            color: #666;
            cursor: pointer;
            padding: 0;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background-color 0.2s;
        }

        .close-btn:hover {
            background: #f0f0f0;
        }

        .settings-description {
            margin-bottom: 20px;
            color: #666;
            line-height: 1.6;
        }

        .filter-tree {
            margin-top: 20px;
        }

        .filter-tree-node {
            margin: 10px 0;
        }

        .filter-node-content {
            display: inline-block;
            padding: 8px 14px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 500;
            user-select: none;
        }

        .filter-node-content:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .filter-node-content.disabled {
            opacity: 0.3;
            filter: grayscale(100%);
        }

        .filter-children {
            margin-left: 30px;
            margin-top: 10px;
        }

        .filter-node-phylum {
            background: linear-gradient(135deg, #f06595, #e64980);
            color: white;
            box-shadow: 0 3px 8px rgba(240, 101, 149, 0.4);
        }

        .filter-node-class {
            background: linear-gradient(135deg, #cc5de8, #be4bdb);
            color: white;
            box-shadow: 0 3px 8px rgba(204, 93, 232, 0.4);
        }

        .modal-footer {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .modal-footer button {
            width: auto;
            padding: 12px 24px;
        }

        .apply-btn {
            background: #52c234;
        }

        .apply-btn:hover {
            background: #3da328;
        }

        .cancel-btn {
            background: #6c757d;
        }

        .cancel-btn:hover {
            background: #5a6268;
        }

        .hint-box {
            background: #d1ecf1;
            border: 2px solid #17a2b8;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            animation: fadeIn 0.5s ease-out;
        }

        .hint-box h4 {
            color: #0c5460;
            margin-bottom: 8px;
            font-size: 0.9em;
            text-transform: uppercase;
        }

        .hint-box p {
            color: #0c5460;
            margin: 0;
            line-height: 1.5;
        }

        @media (max-width: 1024px) {
            .game-container {
                grid-template-columns: 1fr;
            }

            .left-panel {
                position: relative;
                top: 0;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üåø Taxonle</h1>
        <p class="subtitle">Discover the hidden animal through taxonomy!</p>
    </div>

    <div id="loading" class="loading">Loading animal kingdom...</div>

    <div id="gameContainer" class="game-container" style="display: none;">
        <div class="left-panel">
            <div class="stats">
                <div class="stat-item">
                    <span class="stat-label">Guesses Used</span>
                    <span class="stat-value" id="guessCount">0 / 20</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Path Revealed</span>
                    <span class="stat-value" id="pathDepth">0 / 7</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Database Size</span>
                    <span class="stat-value" id="totalAnimals">0</span>
                </div>
            </div>

            <div id="messageArea"></div>

            <div class="input-section">
                <h3>Guess an Animal</h3>
                <div class="search-wrapper">
                    <input
                        type="text"
                        id="guessInput"
                        placeholder="Enter common or scientific name..."
                        autocomplete="off"
                    >
                    <div id="autocompleteList" class="autocomplete-list"></div>
                </div>
                <button id="guessBtn" onclick="makeGuess()">Submit Guess</button>
                <button id="hintBtn" onclick="showHint()" style="background: #17a2b8; margin-top: 10px;">
                    üí° Hint (Locked)
                </button>
                <div class="button-group">
                    <button id="retryBtn" onclick="startNewGame()" style="background: #ffa500;">New Game</button>
                    <button id="giveUpBtn" onclick="giveUp()" style="background: #dc3545;">Give Up</button>
                </div>
            </div>

            <div id="hintsArea" style="margin-top: 20px;"></div>

            <div class="instructions">
                <h4>How to Play</h4>
                <p>‚Ä¢ A mystery animal has been selected</p>
                <p>‚Ä¢ Guess animals to reveal shared taxonomy</p>
                <p>‚Ä¢ The tree shows what you have in common</p>
                <p>‚Ä¢ Closer guesses reveal deeper paths</p>
                <p>‚Ä¢ Find the target animal!</p>
            </div>

            <button class="settings-btn" onclick="openSettings()">‚öôÔ∏è Settings</button>
        </div>

        <div class="tree-panel">
            <div class="tree-header">
                <h2>Taxonomy Tree</h2>
            </div>
            <div id="treeDisplay" class="tree-container">
                <div class="empty-tree">
                    <div class="empty-tree-icon">üå±</div>
                    <div class="empty-tree-text">Start guessing to reveal the tree!</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="modal-overlay" onclick="closeSettingsIfOutside(event)">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-header">
                <h2>‚öôÔ∏è Filter Settings</h2>
                <button class="close-btn" onclick="closeSettings()">&times;</button>
            </div>
            <div class="settings-description">
                Click on taxonomy groups to disable them. Disabled groups (greyed out) will be excluded from the animal pool.
            </div>
            <div id="filterTree" class="filter-tree"></div>
            <div class="modal-footer">
                <button class="cancel-btn" onclick="closeSettings()">Cancel</button>
                <button class="apply-btn" onclick="applyFilterSettings()">Apply & Start New Game</button>
            </div>
        </div>
    </div>

    <script>
        let animals = [];
        let targetAnimal = null;
        let guesses = [];
        let guessCount = 0;
        const maxGuesses = 20;
        let gameOver = false;

        // Tree structure to track revealed nodes
        const revealedTree = {
            kingdom: null,
            phylum: new Set(),
            class: new Set(),
            order: new Set(),
            family: new Set(),
            genus: new Set(),
            species: new Set()
        };

        let deepestLevel = 0;

        // Track disabled taxonomy paths
        let disabledPaths = new Set();
        let pendingDisabledPaths = new Set();

        // Hint system
        let hintsUsed = 0;
        const maxHints = 2;

        // Load animals data
        async function loadAnimals() {
            try {
                const response = await fetch('animals_data.json');
                animals = await response.json();
                updateAnimalCount();
                startNewGame();
                document.getElementById('loading').style.display = 'none';
                document.getElementById('gameContainer').style.display = 'grid';
            } catch (error) {
                document.getElementById('loading').textContent = 'Error loading data. Please refresh.';
                console.error('Error loading animals:', error);
            }
        }

        function startNewGame() {
            const availableAnimals = getFilteredAnimals();
            if (availableAnimals.length === 0) {
                alert('No animals available with current filter settings!');
                return;
            }
            targetAnimal = availableAnimals[Math.floor(Math.random() * availableAnimals.length)];
            guesses = [];
            guessCount = 0;
            gameOver = false;
            deepestLevel = 0;

            // Reset tree
            revealedTree.kingdom = null;
            revealedTree.phylum = new Set();
            revealedTree.class = new Set();
            revealedTree.order = new Set();
            revealedTree.family = new Set();
            revealedTree.genus = new Set();
            revealedTree.species = new Set();

            updateStats();
            renderTree();
            document.getElementById('messageArea').innerHTML = '';
            document.getElementById('guessInput').value = '';
            document.getElementById('guessInput').disabled = false;
            document.getElementById('guessBtn').disabled = false;
            document.getElementById('giveUpBtn').disabled = false;
            document.getElementById('retryBtn').disabled = false;

            // Reset hints
            hintsUsed = 0;
            document.getElementById('hintsArea').innerHTML = '';
            updateHintButton();

            console.log('Target:', targetAnimal);
        }

        // Update hint button state
        function updateHintButton() {
            const hintBtn = document.getElementById('hintBtn');
            const availableHints = Math.floor(guessCount / 5);
            const hintsAvailable = Math.min(availableHints, maxHints) - hintsUsed;

            if (hintsAvailable > 0 && !gameOver) {
                hintBtn.textContent = `üí° Hint (${hintsAvailable} available)`;
                hintBtn.disabled = false;
                hintBtn.style.opacity = '1';
            } else if (hintsUsed >= maxHints) {
                hintBtn.textContent = 'üí° No more hints';
                hintBtn.disabled = true;
                hintBtn.style.opacity = '0.5';
            } else {
                const nextHintAt = (Math.floor(hintsUsed / 1) + 1) * 5;
                hintBtn.textContent = `üí° Hint (Next at ${nextHintAt} guesses)`;
                hintBtn.disabled = true;
                hintBtn.style.opacity = '0.5';
            }
        }

        // Show hint
        function showHint() {
            if (gameOver) return;

            const availableHints = Math.floor(guessCount / 5);
            if (hintsUsed >= availableHints || hintsUsed >= maxHints) {
                return;
            }

            const hintsArea = document.getElementById('hintsArea');

            if (hintsUsed === 0) {
                // First hint: Threat Status
                const hintBox = document.createElement('div');
                hintBox.className = 'hint-box';
                hintBox.innerHTML = `
                    <h4>Hint 1: Conservation Status</h4>
                    <p>${targetAnimal.threatStatus || 'Unknown'}</p>
                `;
                hintsArea.appendChild(hintBox);
            } else if (hintsUsed === 1) {
                // Second hint: Distribution
                const hintBox = document.createElement('div');
                hintBox.className = 'hint-box';
                hintBox.innerHTML = `
                    <h4>Hint 2: Geographic Distribution</h4>
                    <p>${targetAnimal.distribution || 'Unknown'}</p>
                `;
                hintsArea.appendChild(hintBox);
            }

            hintsUsed++;
            updateHintButton();
        }

        // Autocomplete functionality
        const guessInput = document.getElementById('guessInput');
        const autocompleteList = document.getElementById('autocompleteList');

        guessInput.addEventListener('input', function() {
            const searchTerm = this.value.toLowerCase().trim();

            if (searchTerm.length < 2) {
                autocompleteList.style.display = 'none';
                return;
            }

            const matches = getFilteredAnimals()
                .filter(animal =>
                    animal.commonName.toLowerCase().includes(searchTerm) ||
                    animal.scientificName.toLowerCase().includes(searchTerm)
                )
                .slice(0, 15);

            if (matches.length > 0) {
                autocompleteList.innerHTML = matches.map(animal => `
                    <div class="autocomplete-item" onclick="selectAnimal('${escapeHtml(animal.commonName)}')">
                        <div class="autocomplete-item-name">${escapeHtml(animal.commonName)}</div>
                        <div class="autocomplete-item-scientific">${escapeHtml(animal.scientificName)}</div>
                    </div>
                `).join('');
                autocompleteList.style.display = 'block';
            } else {
                autocompleteList.style.display = 'none';
            }
        });

        document.addEventListener('click', function(e) {
            if (!e.target.closest('.search-wrapper')) {
                autocompleteList.style.display = 'none';
            }
        });

        function selectAnimal(name) {
            guessInput.value = name;
            autocompleteList.style.display = 'none';
        }

        guessInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                makeGuess();
            }
        });

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Make a guess
        function makeGuess() {
            if (gameOver) return;

            const input = guessInput.value.trim();
            if (!input) {
                showMessage('Please enter an animal name!', 'error');
                return;
            }

            // Find the animal
            const animal = getFilteredAnimals().find(a =>
                a.commonName.toLowerCase() === input.toLowerCase() ||
                a.scientificName.toLowerCase() === input.toLowerCase()
            );

            if (!animal) {
                showMessage('Animal not available. Check filter settings!', 'error');
                return;
            }

            // Check if already guessed
            if (guesses.some(g => g.scientificName === animal.scientificName)) {
                showMessage('You already guessed this species!', 'info');
                return;
            }

            // Add to guesses
            guesses.push(animal);
            guessCount++;

            // Compare with target and update tree
            const commonLevel = compareWithTarget(animal);

            // Update stats
            updateStats();

            // Update hint button
            updateHintButton();

            // Check if won
            if (animal.scientificName === targetAnimal.scientificName) {
                winGame();
                return;
            }

            // Check if lost
            if (guessCount >= maxGuesses) {
                loseGame();
                return;
            }

            // Clear input
            guessInput.value = '';
            guessInput.focus();
        }

        // Compare guessed animal with target
        function compareWithTarget(guessedAnimal) {
            const levels = ['kingdom', 'phylum', 'class', 'order', 'family', 'genus', 'species'];
            let commonLevel = -1;

            // Always set kingdom to Animalia
            revealedTree.kingdom = 'Animalia';

            // Find deepest common level
            for (let i = 0; i < levels.length; i++) {
                const level = levels[i];
                let guessValue, targetValue;

                if (level === 'kingdom') {
                    guessValue = 'Animalia';
                    targetValue = 'Animalia';
                } else if (level === 'species') {
                    guessValue = guessedAnimal.scientificName;
                    targetValue = targetAnimal.scientificName;
                } else {
                    guessValue = guessedAnimal[level];
                    targetValue = targetAnimal[level];
                }

                if (guessValue && targetValue &&
                    guessValue.toLowerCase() === targetValue.toLowerCase()) {
                    commonLevel = i;

                    // Add to revealed tree
                    if (level !== 'kingdom') {
                        revealedTree[level].add(guessValue);
                    }
                } else {
                    break; // Stop at first divergence
                }
            }

            // Update deepest level revealed
            if (commonLevel > deepestLevel) {
                deepestLevel = commonLevel;
            }

            renderTree();

            const levelName = commonLevel >= 0 ? levels[commonLevel] : 'none';
            return levelName;
        }

        // Build simplified tree showing only shared path and divergence points
        function buildTreeStructure() {
            const levels = ['kingdom', 'phylum', 'class', 'order', 'family', 'genus', 'species'];

            // Build the shared path up to deepestLevel
            const tree = {};
            const pathNodes = []; // Track nodes at each level for placing animals

            let currentNode = tree;

            // Build the common path
            for (let i = 0; i <= deepestLevel; i++) {
                const level = levels[i];
                let value;

                if (level === 'kingdom') {
                    value = 'Animalia';
                } else if (level === 'species') {
                    value = targetAnimal.scientificName;
                } else {
                    value = targetAnimal[level];
                }

                if (value) {
                    currentNode[value] = {
                        name: value,
                        level: level,
                        levelIndex: i,
                        children: {},
                        isSharedPath: true
                    };
                    pathNodes[i] = currentNode[value].children;
                    currentNode = currentNode[value].children;
                }
            }

            // Place each guessed animal at its correct divergence point
            guesses.forEach(animal => {
                // Find how deep this animal matches with target
                let animalDepth = 0;
                for (let i = 0; i < levels.length; i++) {
                    const level = levels[i];
                    let guessValue, targetValue;

                    if (level === 'kingdom') {
                        guessValue = 'Animalia';
                        targetValue = 'Animalia';
                    } else if (level === 'species') {
                        guessValue = animal.scientificName;
                        targetValue = targetAnimal.scientificName;
                    } else {
                        guessValue = animal[level];
                        targetValue = targetAnimal[level];
                    }

                    if (guessValue && targetValue &&
                        guessValue.toLowerCase() === targetValue.toLowerCase()) {
                        animalDepth = i;
                    } else {
                        break;
                    }
                }

                // Place animal at its divergence point
                const divergenceLevel = animalDepth + 1;
                if (divergenceLevel <= 6 && pathNodes[animalDepth]) {
                    const animalKey = `animal_${animal.commonName}`;
                    pathNodes[animalDepth][animalKey] = {
                        name: animal.commonName,
                        scientificName: animal.scientificName,
                        level: 'animal',
                        levelIndex: divergenceLevel,
                        children: {},
                        animal: animal
                    };
                }
            });

            // Add mystery placeholder at the deepest revealed level
            if (!gameOver && deepestLevel < 6 && pathNodes[deepestLevel]) {
                pathNodes[deepestLevel]['mystery'] = {
                    name: '???',
                    level: 'animal',
                    levelIndex: deepestLevel + 1,
                    children: {},
                    mystery: true
                };
            }

            return tree;
        }

        // Generate unique ID for each node
        let nodeIdCounter = 0;
        function generateNodeId() {
            return `node-${nodeIdCounter++}`;
        }

        // Render tree recursively with top-down branching
        function renderTreeNode(node, levelIdx) {
            const levelClasses = ['kingdom', 'phylum', 'class', 'order', 'family', 'genus', 'species'];
            const levelLabels = ['Kingdom', 'Phylum', 'Class', 'Order', 'Family', 'Genus', 'Species'];

            const nodeId = generateNodeId();
            node.id = nodeId;

            let html = '<div class="tree-branch-group">';

            // Node itself
            html += `<div class="tree-node-wrapper" id="${nodeId}">`;

            // Only show level label for shared path nodes (not for animal nodes)
            if (node.isSharedPath) {
                const label = levelLabels[levelIdx];
                html += '<div class="level-label">' + label + '</div>';
                const cssClass = levelClasses[levelIdx];
                html += `<div class="tree-node ${cssClass}">${node.name}</div>`;
            } else if (node.mystery) {
                // Mystery placeholder at divergence point
                html += '<div class="tree-node mystery">???</div>';
            } else if (node.level === 'animal') {
                // Animal node at divergence point (no level label)
                const isTarget = gameOver && node.animal && node.animal.scientificName === targetAnimal.scientificName;
                const cssClass = isTarget ? 'target' : 'species';
                const title = node.scientificName || '';
                html += `<div class="tree-node ${cssClass}" title="${title}">
                    ${node.name}
                </div>`;
            }

            html += '</div>'; // close tree-node-wrapper

            // Render children
            const children = Object.values(node.children);
            if (children.length > 0) {
                html += '<div class="tree-children">';
                children.forEach((child) => {
                    html += renderTreeNode(child, child.levelIndex);
                });
                html += '</div>';
            }

            html += '</div>'; // close tree-branch-group
            return html;
        }

        // Draw smooth SVG connections between nodes
        function drawConnections() {
            const container = document.getElementById('treeDisplay');
            const existingSvg = container.querySelector('.tree-svg');
            if (existingSvg) {
                existingSvg.remove();
            }

            // Get the actual scrollable content area
            const treeContent = container.querySelector('.tree-content');
            if (!treeContent) return;

            const containerRect = container.getBoundingClientRect();
            const contentRect = treeContent.getBoundingClientRect();

            // Create SVG with proper dimensions
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('class', 'tree-svg');

            // Calculate proper SVG dimensions
            const svgWidth = Math.max(contentRect.width, containerRect.width);
            const svgHeight = Math.max(contentRect.height, containerRect.height);

            svg.setAttribute('width', svgWidth);
            svg.setAttribute('height', svgHeight);
            svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
            svg.style.position = 'absolute';
            svg.style.top = '0';
            svg.style.left = '0';
            svg.style.pointerEvents = 'none';
            svg.style.zIndex = '1';
            svg.style.overflow = 'visible';

            // Find all nodes and draw connections to their children
            const allNodes = container.querySelectorAll('.tree-node-wrapper');

            allNodes.forEach(parentNode => {
                const parentRect = parentNode.getBoundingClientRect();
                const parentX = parentRect.left + parentRect.width / 2 - containerRect.left;
                const parentY = parentRect.bottom - containerRect.top;

                // Find children
                const parentGroup = parentNode.closest('.tree-branch-group');
                const childrenContainer = parentGroup.querySelector(':scope > .tree-children');

                if (childrenContainer) {
                    const childWrappers = childrenContainer.querySelectorAll(':scope > .tree-branch-group > .tree-node-wrapper');

                    childWrappers.forEach(childNode => {
                        const childRect = childNode.getBoundingClientRect();
                        const childX = childRect.left + childRect.width / 2 - containerRect.left;
                        const childY = childRect.top - containerRect.top;

                        // Create smooth curved path
                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');

                        // Calculate control points for smooth curve
                        const midY = parentY + (childY - parentY) * 0.5;

                        const pathData = `M ${parentX} ${parentY} C ${parentX} ${midY}, ${childX} ${midY}, ${childX} ${childY}`;

                        path.setAttribute('d', pathData);
                        path.setAttribute('stroke', '#52c234');
                        path.setAttribute('stroke-width', '3');
                        path.setAttribute('fill', 'none');
                        path.setAttribute('opacity', '0.7');
                        path.setAttribute('stroke-linecap', 'round');

                        svg.appendChild(path);
                    });
                }
            });

            container.insertBefore(svg, container.firstChild);
        }

        // Render the tree
        function renderTree() {
            const treeDisplay = document.getElementById('treeDisplay');
            nodeIdCounter = 0;

            if (guesses.length === 0) {
                treeDisplay.innerHTML = `
                    <div class="empty-tree">
                        <div class="empty-tree-icon">üå±</div>
                        <div class="empty-tree-text">Start guessing to reveal the tree!</div>
                    </div>
                `;
                return;
            }

            const tree = buildTreeStructure();
            let html = '<div class="tree-content"><div class="tree-root">';

            // Render from root (should only be Animalia)
            Object.values(tree).forEach(rootNode => {
                html += renderTreeNode(rootNode, rootNode.levelIndex);
            });

            html += '</div></div>';
            treeDisplay.innerHTML = html;

            // Draw connections after DOM is updated
            requestAnimationFrame(() => {
                setTimeout(() => {
                    drawConnections();
                }, 100);
            });
        }

        // Update statistics
        function updateStats() {
            document.getElementById('guessCount').textContent = `${guessCount} / ${maxGuesses}`;
            document.getElementById('pathDepth').textContent = `${deepestLevel} / 7`;
        }

        // Show message
        function showMessage(text, type = 'info') {
            const messageArea = document.getElementById('messageArea');
            messageArea.innerHTML = `<div class="message ${type}">${text}</div>`;

            setTimeout(() => {
                messageArea.innerHTML = '';
            }, 3000);
        }

        // Win game
        function winGame() {
            gameOver = true;
            guessInput.disabled = true;
            document.getElementById('guessBtn').disabled = true;
            document.getElementById('giveUpBtn').disabled = true;
            document.getElementById('retryBtn').disabled = true;
            document.getElementById('hintBtn').disabled = true;

            const messageArea = document.getElementById('messageArea');
            messageArea.innerHTML = `
                <div class="game-over">
                    <h3>üéâ You Found It!</h3>
                    <p><strong>${targetAnimal.commonName}</strong></p>
                    <p><em>${targetAnimal.scientificName}</em></p>
                    <p>Guessed in ${guessCount} ${guessCount === 1 ? 'try' : 'tries'}!</p>
                    <button class="new-game-btn" onclick="startNewGame()">Play Again</button>
                </div>
            `;
        }

        // Lose game
        function loseGame() {
            gameOver = true;
            guessInput.disabled = true;
            document.getElementById('guessBtn').disabled = true;
            document.getElementById('giveUpBtn').disabled = true;
            document.getElementById('retryBtn').disabled = true;
            document.getElementById('hintBtn').disabled = true;

            const messageArea = document.getElementById('messageArea');
            messageArea.innerHTML = `
                <div class="game-over">
                    <h3>Game Over!</h3>
                    <p>The answer was:</p>
                    <p><strong>${targetAnimal.commonName}</strong></p>
                    <p><em>${targetAnimal.scientificName}</em></p>
                    <button class="new-game-btn" onclick="startNewGame()">Try Again</button>
                </div>
            `;
        }

        // Give up
        function giveUp() {
            if (gameOver) return;

            if (!confirm('Are you sure you want to give up and see the answer?')) {
                return;
            }

            gameOver = true;
            guessInput.disabled = true;
            document.getElementById('guessBtn').disabled = true;
            document.getElementById('giveUpBtn').disabled = true;
            document.getElementById('retryBtn').disabled = true;
            document.getElementById('hintBtn').disabled = true;

            // Reveal the target in the tree by setting deepest level to 6
            deepestLevel = 6;

            // Add target to guesses to show it in the tree
            if (!guesses.some(g => g.scientificName === targetAnimal.scientificName)) {
                guesses.push(targetAnimal);
            }

            renderTree();

            const messageArea = document.getElementById('messageArea');
            messageArea.innerHTML = `
                <div class="game-over">
                    <h3>You Gave Up!</h3>
                    <p>The answer was:</p>
                    <p><strong>${targetAnimal.commonName}</strong></p>
                    <p><em>${targetAnimal.scientificName}</em></p>
                    <p>Better luck next time!</p>
                    <button class="new-game-btn" onclick="startNewGame()">Try Again</button>
                </div>
            `;
        }

        // Redraw connections on window resize
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (guesses.length > 0) {
                    drawConnections();
                }
            }, 100);
        });

        // Settings Modal Functions
        function openSettings() {
            // Copy active settings to pending
            pendingDisabledPaths = new Set(disabledPaths);
            buildFilterTree();
            document.getElementById('settingsModal').classList.add('active');
        }

        function closeSettings() {
            document.getElementById('settingsModal').classList.remove('active');
        }

        function applyFilterSettings() {
            // Apply pending changes to active
            disabledPaths = new Set(pendingDisabledPaths);
            updateAnimalCount();
            closeSettings();
            startNewGame();
        }

        function closeSettingsIfOutside(event) {
            if (event.target.id === 'settingsModal') {
                closeSettings();
            }
        }

        // Build taxonomy filter tree (top 3 levels: Kingdom, Phylum, Class)
        function buildFilterTree() {
            const tree = {};

            animals.forEach(animal => {
                const phylum = animal.phylum || 'Unknown';
                const className = animal.class || 'Unknown';

                if (!tree[phylum]) {
                    tree[phylum] = new Set();
                }
                tree[phylum].add(className);
            });

            renderFilterTree(tree);
        }

        // Render the filter tree in the modal
        function renderFilterTree(tree) {
            const container = document.getElementById('filterTree');
            let html = '<div class="filter-tree-node">';

            // Kingdom (always Animalia)
            html += '<div class="filter-node-content filter-node-phylum" style="background: linear-gradient(135deg, #ff6b6b, #ee5a6f);">Animalia (Kingdom)</div>';

            // Phyla and Classes
            const sortedPhyla = Object.keys(tree).sort();
            sortedPhyla.forEach(phylum => {
                const phylumPath = `phylum:${phylum}`;
                const phylumDisabled = pendingDisabledPaths.has(phylumPath);

                html += '<div class="filter-children">';
                html += `<div class="filter-tree-node">`;
                html += `<div class="filter-node-content filter-node-phylum ${phylumDisabled ? 'disabled' : ''}"
                         onclick="toggleTaxonomyPath('${phylumPath}')">
                         ${phylum}
                         </div>`;

                // Classes under this phylum
                const sortedClasses = Array.from(tree[phylum]).sort();
                if (sortedClasses.length > 0) {
                    html += '<div class="filter-children">';
                    sortedClasses.forEach(className => {
                        const classPath = `phylum:${phylum}|class:${className}`;
                        const classDisabled = pendingDisabledPaths.has(classPath) || phylumDisabled;

                        html += `<div class="filter-tree-node">`;
                        html += `<div class="filter-node-content filter-node-class ${classDisabled ? 'disabled' : ''}"
                                 onclick="toggleTaxonomyPath('${classPath}', '${phylumPath}')">
                                 ${className}
                                 </div>`;
                        html += '</div>';
                    });
                    html += '</div>';
                }

                html += '</div>';
                html += '</div>';
            });

            html += '</div>';
            container.innerHTML = html;
        }

        // Toggle taxonomy path on/off (modifies pending changes only)
        function toggleTaxonomyPath(path, parentPath) {
            if (pendingDisabledPaths.has(path)) {
                // Enable this path and all children
                const pathsToRemove = Array.from(pendingDisabledPaths).filter(p => p === path || p.startsWith(path + '|'));
                pathsToRemove.forEach(p => pendingDisabledPaths.delete(p));
            } else {
                // Disable this path (children will be implicitly disabled)
                pendingDisabledPaths.add(path);

                // If parent is disabled, we don't need to explicitly disable children
                if (parentPath && pendingDisabledPaths.has(parentPath)) {
                    pendingDisabledPaths.delete(path);
                }
            }

            buildFilterTree();
        }

        // Filter animals based on disabled paths
        function getFilteredAnimals() {
            if (!animals || animals.length === 0) {
                return [];
            }

            if (disabledPaths.size === 0) {
                return animals;
            }

            return animals.filter(animal => {
                const phylum = animal.phylum || 'Unknown';
                const className = animal.class || 'Unknown';

                const phylumPath = `phylum:${phylum}`;
                const classPath = `phylum:${phylum}|class:${className}`;

                // If phylum is disabled, exclude
                if (disabledPaths.has(phylumPath)) {
                    return false;
                }

                // If class is disabled, exclude
                if (disabledPaths.has(classPath)) {
                    return false;
                }

                return true;
            });
        }

        // Update animal count in stats
        function updateAnimalCount() {
            const filteredCount = getFilteredAnimals().length;
            document.getElementById('totalAnimals').textContent = filteredCount;
        }

        // Initialize
        loadAnimals();
    </script>
</body>
</html>
